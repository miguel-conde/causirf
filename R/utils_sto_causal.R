# https://royalsocietypublishing.org/doi/10.1098/rspa.2021.0835

#' Extends the data with lags
#'
#' @param in_dataa tibble, one of the colummns must account for the cause and
#' the other for the effect.
#' @param cause name of the column accounting for the cause
#' @param effect name of the column accounting for the effect
#' @param J number of positive and negative lags composing the IRF
#'
#' @return the \code{in_data} tibble extended with \code{2J+1} lag columns
#'
#' @encoding UTF-8
#'
#' @import dplyr
#' @import tidyr
#' @importFrom rlang :=
#'
#' @keywords internal
#'
make_probe_x_y <- function(in_data, cause, effect, J = 10) {

  probe_x_y <- in_data
  for (i in -J:J) {
    FUN <- ifelse(i > 0, lag, lead)

    probe_x_y <- probe_x_y %>%
      mutate(!!sym(paste0("lag_", i)) := FUN(!!sym(cause), n = abs(i)))
  }

  probe_x_y <- probe_x_y %>% drop_na()

  return(probe_x_y)
}

#' Cost function to estimate IRF using least-squares
#'
#' @param g numeric vector for the IRF, with \code{J} elements
#' @param L,J,X,Y,psi,lambda objects used to compute de cost function value
#'
#' @return the value of the cost function at \code{g}
#'
#' @encoding UTF-8
#'
#' @keywords internal
#'
cost_fun <- function(g, L, J, X, Y, psi, lambda) {

  v_t <- Y - X %*% g
  mu_v <- mean(v_t)
  mu <- rep(mu_v, L - 2*J) %>% as.matrix

  t(Y - mu - X %*% g) %*% (Y - mu - X %*% g) +
    lambda * t(g) %*% t(psi) %*% psi %*% g

}

#' Build the matrix for the roughness index
#'
#' @param J
#'
#' @return a matrix with \code{2Jâˆ’1} rows and \code{2J+1} columns
#'
#' @encoding UTF-8
#' @keywords internal
#'
make_psi <- function(J) {

  out <- matrix(0, nrow = 2*J-1, ncol = 2*J+1)

  for (i in 1:nrow(out)) {
    for (j in 1:ncol(out)) {
      if (j == i+1) out[i, j] <- 2
      else if (abs(j-i-1) == 1) out[i,j] <- 1
    }
  }
  return(out)
}

#' Estimate the Impulse Response Function (IRF)
#'
#' This function estimates the IRF between 2 stochastic processes, one taken
#' as one of the causes of the other.
#'
#' @param in_data a tibble, one of the colummns must account for the cause and
#' the other for the effect.
#' @param cause name of the column accounting for the cause
#' @param effect name of the column accounting for the effect
#' @param J number of positive and negative lags composing the IRF
#' @param lambda weight multiplier to constrain the roughness index (weight of
#' the penalty from the roughness index)
#'
#' @references
#' \itemize{
#' \item \href{https://royalsocietypublishing.org/doi/10.1098/rspa.2021.0835}{Revisiting causality using stochastics: 1. Theory},
#' \item \href{https://royalsocietypublishing.org/doi/10.1098/rspa.2021.0836}{Revisiting causality using stochastics: 2. Applications}
#'}
#'
#' @return an \code{est_causal} object, a list containing:
#'
#' \itemize{
#' \item \code{X}, \code{Y}, \code{L}, \code{J}, \code{psi}: objects used in the optimization
#' \item \code{cause}, \code{effect}: names of the cause and the effect
#' \item \code{res_optim}: result of \link[stats:optim]{stats::optim}
#' }
#'
#' @importFrom stats optim
#' @export
#'
#' @encoding UTF-8
#'
#' @seealso \code{\link[causirf:autoplot.est_causal]{causirf::autoplot}},
#' \code{\link[causirf:evr]{causirf::evr}}
#'
#' @examples
#' \dontrun{
#' library(causirf)
#' library(ggplot2)
#'
#' data(temp_co2_data)
#'
#' obj_causal_temp_co2 <- est_irf(temp_co2_data, "temp", "co2", J = 20, lambda = 10)
#'
#' autoplot(obj_causal_temp_co2)
#'
#' evr(obj_causal_co2_temp)
#' }
est_irf <- function(in_data, cause, effect, J = 20, lambda = 10) {

  L <- nrow(in_data)
  probe <- make_probe_x_y(in_data %>% select(all_of(c(cause, effect))), cause, effect, J = J)
  X <- probe %>% select(-all_of(c(cause, effect))) %>% as.matrix()
  Y <- probe %>% select(all_of(effect)) %>% as.matrix()
  psi <- make_psi(J)

  res_optim <- optim(rep(0, 2*J+1), fn = cost_fun,
                     L = L, J= J, X= X, Y = Y, psi = psi, lambda = lambda,
                     method = "L-BFGS-B", lower = 0)

  out <- list(X = X,
              Y = Y,
              L = L,
              J = J,
              psi = psi,
              cause = cause,
              effect = effect,
              res_optim = res_optim)

  class(out) <- c("est_causal", class(out))

  return(out)
}

#' Compute the Explained Variance Ratio (EVR)
#'
#' @param obj an \code{est_causal} object generated by \code{\link[causirf:est_irf]{causirf::est_irf}}
#'
#' @return an estimate for the EVR of \code{obj}
#'
#' @importFrom stats var
#' @export
#'
#' @encoding UTF-8
#'
#' @seealso \code{\link[causirf:autoplot.est_causal]{causirf::autoplot}},
#' \code{\link[causirf:est_irf]{causirf::est_irf}}
#'
#' @examples
#' \dontrun{
#' library(causirf)
#' library(ggplot2)
#'
#' data(temp_co2_data)
#'
#' obj_causal_temp_co2 <- est_irf(temp_co2_data, "temp", "co2", J = 20, lambda = 10)
#'
#' autoplot(obj_causal_temp_co2)
#'
#' evr(obj_causal_co2_temp)
#' }
evr <- function(obj) {

  v_t <- obj$Y - obj$X %*% matrix(obj$res_optim$par)
  mu_v <- mean(v_t)
  mu <- rep(mu_v, obj$L - 2*obj$J) %>% as.matrix()
  hat_gamma_nu <- 1 / (obj$L - 2*obj$J) * t(obj$Y - mu - obj$X %*% matrix(obj$res_optim$par)) %*%
    (obj$Y - mu - obj$X %*% matrix(obj$res_optim$par))
  hat_gamma_y = var(obj$Y)

  e <- 1 - hat_gamma_nu / hat_gamma_y

  return(e)
}


#' Plot an estimated IRF
#'
#' @param object an \code{est_causal} object generated by \code{\link[causirf:est_irf]{causirf::est_irf}}
#' @param ... other arguments passed to specific methods
#'
#' @return a ggplot object
#'
#' @import ggplot2
#' @importFrom ggplot2 autoplot
#'
#' @export
#'
#' @encoding UTF-8
#'
#' @seealso \code{\link[causirf:est_irf]{causirf::est_irf}},
#' \code{\link[causirf:evr]{causirf::evr}}
#'
#' @examples
#' \dontrun{
#' library(causirf)
#' library(ggplot2)
#'
#' data(temp_co2_data)
#'
#' obj_causal_temp_co2 <- est_irf(temp_co2_data, "temp", "co2", J = 20, lambda = 10)
#'
#' autoplot(obj_causal_temp_co2)
#'
#' evr(obj_causal_co2_temp)
#' }
autoplot.est_causal <- function(object, ...) {

  gg_res_optim <- tibble(x = 1:ncol(object$X),
                         time_lag = colnames(object$X),
                         irf = object$res_optim$par)

  the_title <- paste(object$effect, "--->", object$cause)
  the_subtitle <- paste("Explained Variance Ratio:",
                        sprintf("%.3f", as.numeric(evr(object))))

  p <- ggplot(data = gg_res_optim,
              mapping = aes(x = x, y = irf, color = x > object$J)) +
    geom_point(show.legend = FALSE) +
    geom_line(show.legend = FALSE) +
    geom_vline(xintercept = object$J+1, linetype = 2) +
    scale_x_continuous(breaks = 1:(2*object$J+1), labels = gg_res_optim$time_lag) +
    labs(title = the_title, subtitle = the_subtitle) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

  return(p)
}


